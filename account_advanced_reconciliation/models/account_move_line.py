# -*- coding: utf-8 -*-
###############################################################################
#    License, author and contributors information in:                         #
#    __manifest__.py file at the root folder of this module.                  #
###############################################################################

from odoo import models, fields
from odoo.tools import float_compare
from odoo.exceptions import UserError
from odoo.tools.translate import _
from logging import getLogger

_logger = getLogger(__name__)


class AccountMoveLine(models.Model):
    _inherit = "account.move.line"

    origin_move_info = fields.Char(
        string='Info about move line from which it was generated',
        help='''
Technical field to have historical information about the origin of move line. When a move line it was split, the id of 
the origin move line it was set on each move line (the origin one and the new move line generated by the split operation
). This field is useful for regroup operation (Example when reconciliation was undone).
''',
        copy=False,
    )

    def reconcile(self, writeoff_acc_id=False, writeoff_journal_id=False):
        # Retrieve debit and credit moves
        debit_moves = self.filtered(lambda r: r.debit != 0 or r.amount_currency > 0)
        credit_moves = self.filtered(lambda r: r.credit != 0 or r.amount_currency < 0)
        debit_moves = debit_moves.sorted(key=lambda a: (a.date_maturity or a.date, a.currency_id))
        credit_moves = credit_moves.sorted(key=lambda a: (a.date_maturity or a.date, a.currency_id))
        # Compute on which field reconciliation should be based upon:
        if self[0].account_id.currency_id and self[0].account_id.currency_id != self[0].account_id.company_id.currency_id:
            field = 'amount_residual_currency'
        else:
            field = 'amount_residual'
        (debit_moves + credit_moves).read([field])
        while debit_moves and credit_moves:
            # This print is not an error. This is used for correct work of debug.
            print("--debug purpose---")
            print(debit_moves)
            print(credit_moves)
            print("--debug purpose end---")
            move_lines = self.env['account.move.line']
            debit_move = debit_moves[0]
            credit_move = credit_moves[0]
            # Get the amount to reconcile
            amount_reconcile = min(debit_move.amount_residual, -credit_move.amount_residual)
            amount_reconcile_currency = min(debit_move.amount_residual_currency, -credit_move.amount_residual_currency)
            # Compare the debit and the credit amount residual
            compare = float_compare(
                debit_move[field],
                -credit_move[field],
                precision_rounding=credit_move.move_id.currency_id.rounding
            )
            # If debit and credit has the same import,
            if compare == 0:
                move_lines += (debit_move + credit_move)
                debit_moves -= debit_move
                credit_moves -= credit_move
            # This means that debit move is lower than credit move and then credit move must to be split
            elif compare < 0:
                move_line_to_reconcile = credit_move.split_move_line(
                    amount_reconcile,
                    amount_reconcile_currency,
                    'credit'
                )
                move_lines += (debit_move + move_line_to_reconcile)
                debit_moves -= debit_move
            # This means that debit move is greater than credit move and the debit move must to be split
            else:
                move_line_to_reconcile = debit_move.split_move_line(
                    amount_reconcile,
                    amount_reconcile_currency,
                    'debit'
                )
                move_lines += (move_line_to_reconcile + credit_move)
                credit_moves -= credit_move
            # Calling the super function.
            super(AccountMoveLine, move_lines).reconcile(writeoff_acc_id, writeoff_journal_id)
        return super(AccountMoveLine, (debit_moves + credit_moves)).reconcile(writeoff_acc_id, writeoff_journal_id)

    def split_move_line(self, amount, amount_currency, debit_credit):
        """
        This function splits the line in two by updating both amount.
        :param amount: the amount to create for new line / used for compute amount on old line
        :param amount_currency: the same thing of the amount but in currency
        :param debit_credit: the origin move line is debit or credit (debit|credit)
        :return: the created new line
        """
        # Create the new line with the correct amount
        move_value = self._get_default_value(debit_credit, amount, amount_currency)
        new_move_line = self.with_context(check_move_validity=False).copy(move_value)
        # Post update copy
        new_move_line.post_update_copy(original_line=self)
        if 'avoid_update_origin_line' in self._context and self._context['avoid_update_origin_line']:
            return new_move_line
        # Update the old line by updating amount and origin info.
        move_value = {
            debit_credit: self[debit_credit] - amount,
            'origin_move_info': str(self.id),
            'amount_currency': self.amount_currency - (
                -amount_currency if debit_credit == 'credit' else amount_currency
            ),
            'amount_residual': self.amount_residual - (-amount if debit_credit == 'credit' else amount),
            'amount_residual_currency': self.amount_residual_currency - (
                -amount_currency if debit_credit == 'credit' else amount_currency
            )
        }
        self.update(move_value)
        self.flush()
        return new_move_line

    def post_update_copy(self, original_line):
        """
        This function is useful to avoid onchange method that impact on the account move line field.
        In this function it will be set the fields that should be overwritten in onchange function.
        :return:
        """
        self.ensure_one()
        value_to_update = {
            'name': original_line.name
        }
        # To avoid inherit for only one field
        if hasattr(original_line, 'payment_type_id'):
            payment_term = getattr(original_line, 'payment_type_id')
            value_to_update['payment_type_id'] = payment_term.id
        self.write(value_to_update)

    def _get_default_value(self, debit_credit, amount, amount_currency) -> dict:
        """
        Return the default value for copy
        """
        return {
            debit_credit: amount,
            'payment_id': self.payment_id.id,
            'origin_move_info': str(self.id),
            'amount_currency': -amount_currency if debit_credit == 'credit' else amount_currency,
            'amount_residual': -amount if debit_credit == 'credit' else amount,
            'amount_residual_currency': -amount_currency if debit_credit == 'credit' else amount_currency,
        }

    def _create_writeoff(self, writeoff_vals):
        line = super(AccountMoveLine, self)._create_writeoff(writeoff_vals)
        # Retrieve the amount for threshold check
        threshold = self.env.user.company_id.bank_reconciliation_threshold
        # Retrieve the amount of the line
        line_amount = abs(line.debit if line.debit else line.credit)
        if line_amount > threshold:
            raise UserError(_("The deficit between debit and credit exceed the admitted threshold value."))
        return line

    def remove_move_reconcile(self):
        # First save the move to recompile
        moves = self.mapped('matched_debit_ids.credit_move_id')
        moves += self.mapped('matched_debit_ids.debit_move_id')
        moves += self.mapped('matched_credit_ids.credit_move_id')
        moves += self.mapped('matched_credit_ids.debit_move_id')
        res = super(AccountMoveLine, self).remove_move_reconcile()
        # Retrieve all the origin_move_info
        origin_move_info_ids = moves.mapped('origin_move_info')
        origin_move_info_ids = [int(x) for x in origin_move_info_ids]
        for origin_move_info in origin_move_info_ids:
            # Check if, for thr same origin move, exist move that has reconcile. If exist no recompile is permitted
            moves_to_recompile = self.env['account.move.line'].search([
                ('origin_move_info', '=', origin_move_info)
            ])
            if not moves_to_recompile:
                continue
            if any([move.full_reconcile_id for move in moves_to_recompile]):
                continue
            # Recompile moves
            moves_to_recompile.recompile_moves()
        return res

    def recompile_moves(self):
        # Check before recompile
        if not self._can_recompile_moves():
            return False
        # Recompile moves
        # Try to recompile on origin move
        move = self.filtered(lambda m: m.id == int(m.origin_move_info))
        # Otherwise on the first one
        if not move:
            move = self[0]
        move.with_context(check_move_validity=False).write({
            'debit': sum([x.debit for x in self]),
            'credit': sum([x.credit for x in self]),
            'amount_currency': sum([x.amount_currency for x in self]),
            'amount_residual': sum([x.amount_residual for x in self]),
            'amount_residual_currency': sum([x.amount_residual_currency for x in self]),
        })
        (self - move).unlink()
        return True

    def _can_recompile_moves(self):
        """
        Check for recompile moves
        :return: True if recompile is possible, False otherwise.
        """
        # Moves has to be same date_maturity
        if len(set(self.mapped('date_maturity'))) > 1:
            return False
        # Moves has to be referred to the same payment
        if len(set(self.mapped('payment_id'))) > 1:
            return False
        return True
